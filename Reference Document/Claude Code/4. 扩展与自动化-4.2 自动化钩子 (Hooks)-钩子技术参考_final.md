---
title: "Claude Code 钩子技术参考手册：完整配置指南与高级用法"
description: "深入了解 Claude Code 钩子的完整技术规范，包括配置文件结构、事件类型、输入输出格式、JSON 控制机制以及安全最佳实践。"
date: "2026-02-10"
tool: "Claude Code"
---

import AdPlaceholder from '@/components/AdPlaceholder'

# Claude Code 钩子技术参考手册

Claude Code 钩子系统提供了丰富的配置选项和事件类型，支持从简单的命令执行到复杂的基于 LLM 的智能决策。本手册旨在帮助开发者深入理解钩子的技术细节，掌握高级配置技巧，从而构建出真正满足业务需求的自定义工作流程。掌握这些技术要点后，您将能够充分利用钩子的全部潜力。

<AdPlaceholder />

## 前置条件

本参考手册面向有一定钩子使用经验的开发者，建议您已阅读过入门指南并成功创建过基本钩子。在深入本手册之前，请确保您已理解以下概念：

- 钩子的基本配置结构和常用事件类型
- JSON 格式的基本语法和转义规则
- 命令行脚本的编写和调试方法

## 配置文件详解

### 文件位置与优先级

Claude Code 钩子配置支持多个存储位置，按照优先级从高到低排列如下：

**项目级配置**存储在 `.claude/settings.json` 文件中，仅对当前项目生效。这种配置方式适合定义项目特定的工作流程规范，比如强制执行代码格式化标准或项目特定的测试流程。所有团队成员共享此配置，是保持团队代码风格一致性的有效手段。

**用户级配置**存储在 `~/.claude/settings.json` 文件中，对您所有的项目生效。适合放置通用的工具配置和跨项目的默认行为，如通用的日志记录钩子或全局的通知设置。

**本地覆盖配置**使用 `.claude/settings.local.json` 文件，未提交到版本控制系统。这允许您在不影响团队配置的情况下进行个人化的调整，非常适合开发环境的临时测试和实验。

### 配置结构

钩子配置采用 JSON 格式，按事件类型组织，每个事件可以包含多个匹配器：

```json
{
  "hooks": {
    "EventName": [
      {
        "matcher": "ToolPattern",
        "hooks": [
          {
            "type": "command",
            "command": "your-command-here",
            "timeout": 60
          }
        ]
      }
    ]
  }
}
```

**matcher** 字段用于过滤特定工具，区分大小写。支持三种匹配方式：精确匹配（如 `Write` 只匹配 Write 工具）、正则表达式（如 `Edit|Write` 匹配 Edit 或 Write 工具）、通配符（`*` 匹配所有工具）。对于不需要匹配器的全局事件如 `UserPromptSubmit` 或 `Stop`，可以省略 matcher 字段。

**hooks** 数组包含要执行的具体钩子配置，支持两种类型：`command` 类型用于执行 bash 命令，`prompt` 类型用于基于 LLM 的智能评估。`timeout` 参数以秒为单位设置单个钩子的最大执行时间，避免长时间运行的脚本影响开发效率。

<AdPlaceholder />

## 钩子事件类型完整解析

### PreToolUse 事件

PreToolUse 是最常用的钩子事件之一，在工具参数创建之后、实际调用之前触发。这个事件提供了对工具执行的完全控制能力，包括允许、拒绝和参数修改。

**支持的匹配器**覆盖了 Claude Code 的所有工具类型：Bash 用于 shell 命令执行、Glob 用于文件模式匹配、Grep 用于内容搜索、Read 用于读取文件、Edit 用于修改文件、Write 用于创建或覆盖文件、WebFetch 和 WebSearch 用于网络操作。

**权限决策**功能允许 PreToolUse 钩子直接影响权限系统行为。退出代码 0 表示允许执行并继续正常流程；退出代码 2 表示阻止操作，错误信息显示给 Claude；其他非零退出代码表示非阻止错误，执行继续但错误信息会在详细模式中显示。

**参数修改**高级功能允许钩子在执行前修改工具输入参数。通过返回包含 `updatedInput` 的 JSON 输出，可以动态调整命令内容、文件路径或其他参数，实现条件化的自动审批流程。

### PostToolUse 事件

PostToolUse 在工具成功完成后立即触发，适合执行后续处理和结果验证任务。由于工具已经执行完毕，这个事件无法阻止操作，但可以向 Claude 提供反馈信息。

这个事件的典型应用场景包括：代码格式化（文件编辑后自动格式化）、日志记录（记录所有执行的操作）、质量检查（验证生成代码是否符合规范）以及自动测试（在代码修改后运行测试套件）。

### PermissionRequest 事件

PermissionRequest 在向用户显示权限对话框时触发，可以代表用户自动做出权限决策。这对于建立自动化审批流程特别有价值，比如自动批准低风险操作、只对高风险操作请求确认。

### Notification 事件

Notification 事件支持多种通知类型过滤：`permission_prompt` 捕获权限请求通知、`idle_prompt` 捕获空闲提示（Claude 等待用户输入超过 60 秒）、`auth_success` 捕获身份验证成功通知、`elicitation_dialog` 捕获 MCP 工具引出需求通知。

### 用户交互事件

**UserPromptSubmit** 在用户提交提示时、Claude 处理之前触发，可以添加额外上下文、验证提示内容或阻止特定类型的提示。这个事件非常适合实现自定义的提示验证逻辑和上下文注入机制。

**Stop** 事件在主 Claude Code agent 完成响应时触发，如果停止是由于用户主动中断则不会运行。适合用于会话结束前的清理工作或最终验证检查。

**SubagentStop** 事件在子代理任务完成时触发，可以用于验证子代理工作成果或触发后续操作。

### 会话生命周期事件

**SessionStart** 在 Claude Code 启动新会话或恢复现有会话时触发，支持多种触发源：`startup` 来自启动调用、`resume` 来自 `--resume` 或 `/resume` 恢复操作、`clear` 来自 `/clear` 清除操作、`compact` 来自压缩操作。这个事件对于加载开发上下文、安装依赖项或设置环境变量非常有用。

**SessionEnd** 在 Claude Code 会话结束时触发，`reason` 字段指示结束原因：`clear` 表示使用 /clear 清除、`logout` 表示用户注销、`prompt_input_exit` 表示用户在提示输入可见时退出、`other` 表示其他原因。适合执行清理任务和保存会话状态。

### 上下文管理事件

**PreCompact** 在 Claude Code 即将运行压缩操作之前触发，支持 `manual`（手动调用）和 `auto`（自动触发）两种触发类型。这个事件允许您在上下文压缩前进行干预或记录状态。

<AdPlaceholder />

## 基于 LLM 的智能钩子

除了传统的 bash 命令钩子，Claude Code 还支持基于提示的智能钩子（`type: "prompt"`）。这种钩子使用 LLM 来评估操作上下文并做出智能决策，特别适合需要语义理解的复杂场景。

### 工作原理

基于提示的钩子不是执行预定义的命令，而是将操作上下文发送给快速 LLM（如 Haiku 模型），由 LLM 根据提示词做出决策并返回结构化的 JSON 响应。这种方式能够实现上下文感知的智能判断，而不仅仅是规则匹配。

### 配置示例

```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "Evaluate if Claude should stop: $ARGUMENTS. Check if all tasks are complete.",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

使用 `$ARGUMENTS` 占位符插入完整的 hook 输入 JSON 数据。如果提示中不包含 `$ARGUMENTS`，输入数据会自动附加到提示末尾。

### 响应格式

LLM 必须返回包含决策信息的 JSON 格式：

```json
{
  "ok": true,
  "reason": "All tasks completed successfully"
}
```

`ok` 字段为 `true` 表示允许操作，`false` 表示阻止操作。`reason` 字段在 `ok` 为 `false` 时为必需参数，会显示给 Claude 作为决策解释。

### 与 Bash 钩子的对比

| 特性 | Bash 命令钩子 | 基于提示的钩子 |
|------|--------------|--------------|
| 执行方式 | 运行本地脚本 | 调用 LLM API |
| 决策逻辑 | 硬编码的规则 | 自然语言理解 |
| 配置复杂度 | 需要编写脚本 | 配置提示词即可 |
| 上下文感知 | 依赖脚本解析 | 原生支持 |
| 响应速度 | 即时执行 | 需等待 API |
| 适用场景 | 确定性规则 | 语义判断场景 |

### 最佳实践

基于提示的钩子在设计上应遵循以下原则：提示词要具体明确，告诉 LLM 需要评估什么；列出清晰的决策标准，帮助 LLM 做出一致判断；设置合理的超时时间（默认 30 秒），避免长时间等待；针对复杂判断场景使用，避免简单的规则判断场景浪费 API 资源。

<AdPlaceholder />

## 钩子输入输出详解

### 输入数据格式

钩子通过 stdin 接收 JSON 格式的输入数据，包含会话信息和事件特定数据：

```json
{
  "session_id": "abc123",
  "transcript_path": "/Users/.../.claude/projects/.../transcript.jsonl",
  "cwd": "/Users/...",
  "permission_mode": "default",
  "hook_event_name": "PreToolUse",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "/path/to/file.txt",
    "content": "file content"
  },
  "tool_use_id": "toolu_01ABC123..."
}
```

常见字段包括：`session_id` 标识当前会话、`transcript_path` 指向对话记录文件、`cwd` 是执行时的当前工作目录、`permission_mode` 指示当前权限模式、`hook_event_name` 标明触发的事件类型。

### 输出控制机制

钩子通过退出代码和 stdout/stderr 传达状态和信息。**退出代码 0** 表示成功，stdout 中的 JSON 会被解析为结构化控制输出。**退出代码 2** 表示阻止错误，直接使用 stderr 作为错误消息。**其他非零退出代码** 表示非阻止错误，stderr 在详细模式中显示但执行继续。

### JSON 高级输出控制

所有钩子类型都可以返回包含控制字段的 JSON：

```json
{
  "continue": true,
  "stopReason": "operation prevented by security policy",
  "suppressOutput": true,
  "systemMessage": "Warning: Security policy violation detected"
}
```

`continue` 设为 false 会让 Claude 在钩子执行后停止处理。`suppressOutput` 可以隐藏 stdout 输出，避免在详细模式中显示敏感信息。`systemMessage` 用于向用户显示警告信息。

### PreToolUse 专用控制

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "allow",
    "permissionDecisionReason": "Security check passed",
    "updatedInput": {
      "command": "npm run lint --fix"
    }
  }
}
```

`permissionDecision` 支持三种值：`allow` 绕过权限系统、`deny` 阻止执行、`ask` 要求用户确认。`updatedInput` 允许在执行前修改工具参数，结合 `allow` 使用可以实现条件化自动审批。

### UserPromptSubmit 上下文注入

```json
{
  "decision": "block",
  "reason": "Prompt contains potential security risks",
  "hookSpecificOutput": {
    "hookEventName": "UserPromptSubmit",
    "additionalContext": "Current user context: senior developer"
  }
}
```

设置 `decision` 为 `block` 可以阻止提示处理，`additionalContext` 允许注入额外信息作为对话上下文。对于简单用例，也可以直接打印文本到 stdout，同样会被注入为上下文。

<AdPlaceholder />

## 项目特定钩子脚本

### 使用环境变量

项目特定的钩子脚本应使用 `$CLAUDE_PROJECT_DIR` 环境变量来引用文件，这个变量指向项目根目录，无论当前工作目录如何变化都能正确定位脚本：

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/check-style.sh"
          }
        ]
      }
    ]
  }
}
```

这种方法确保钩子脚本在不同的执行环境中都能找到正确的文件路径，是编写可移植钩子的最佳实践。

### 持久化环境变量

SessionStart 钩子可以使用 `CLAUDE_ENV_FILE` 环境变量来持久化设置，这些变量会在整个会话期间对后续的 bash 命令生效：

```bash
#!/bin/bash

if [ -n "$CLAUDE_ENV_FILE" ]; then
  echo 'export NODE_ENV=development' >> "$CLAUDE_ENV_FILE"
  echo 'export API_URL=http://localhost:3000' >> "$CLAUDE_ENV_FILE"
fi

exit 0
```

更高级的用法是捕获环境变更并持久化所有修改，例如使用 nvm 时：

```bash
#!/bin/bash

ENV_BEFORE=$(export -p | sort)

source ~/.nvm/nvm.sh
nvm use 20

if [ -n "$CLAUDE_ENV_FILE" ]; then
  ENV_AFTER=$(export -p | sort)
  comm -13 <(echo "$ENV_BEFORE") <(echo "$ENV_AFTER") >> "$CLAUDE_ENV_FILE"
fi

exit 0
```

这种方法在团队开发中特别有用，可以确保每个开发者使用相同的 Node.js 版本和其他环境配置。

<AdPlaceholder />

## MCP 工具钩子配置

### MCP 工具命名规范

当 MCP 服务器提供工具时，它们遵循特殊的命名模式：`mcp__<server>__<tool>`。例如 `mcp__memory__create_entities` 来自 Memory 服务器，`mcp__filesystem__read_file` 来自 Filesystem 服务器，`mcp__github__search_repositories` 来自 GitHub 服务器。

### 配置 MCP 钩子

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "mcp__memory__.*",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'Memory operation initiated' >> ~/mcp-operations.log"
          }
        ]
      },
      {
        "matcher": "mcp__.*__write.*",
        "hooks": [
          {
            "type": "command",
            "command": "/home/user/scripts/validate-mcp-write.py"
          }
        ]
      }
    ]
  }
}
```

第一个匹配器监听所有 Memory 服务器的操作，第二个匹配器监听所有 MCP 服务器中包含 "write" 的操作。这种精细的控制让您可以为不同类型的 MCP 工具定义不同的处理逻辑。

<AdPlaceholder />

## 插件钩子系统

### 工作原理

插件可以提供与用户和项目钩子无缝集成的 hooks。插件 hooks 在插件的 `hooks/hooks.json` 文件中定义，或通过配置中的 `hooks` 字段指定自定义路径。启用插件时，其 hooks 会自动与用户配置合并。

### 插件钩子配置示例

```json
{
  "description": "Automatic code formatting plugin",
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "${CLAUDE_PLUGIN_ROOT}/scripts/format.sh",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

插件钩子可以使用 `${CLAUDE_PLUGIN_ROOT}` 环境变量引用插件目录内的文件，`${CLAUDE_PROJECT_DIR}` 引用项目根目录。多个 hooks 可以响应同一事件，它们会并行执行。

### 与组件集成的钩子

Skills、subagents 和 slash commands 也可以在 frontmatter 中定义自己的 hooks，这些 hooks 作用域限于组件生命周期：

```yaml
---
name: secure-operations
description: Perform operations with security checks
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/security-check.sh"
---
```

这种定义方式让钩子随组件自动启用和禁用，非常适合创建可复用的功能包。组件级钩子还支持 `once` 选项，设置为 true 时钩子只会在每个会话中运行一次。

<AdPlaceholder />

## 安全最佳实践

### 核心安全原则

编写安全的钩子需要遵循以下关键原则。首先，**验证和清理所有输入**，永远不要盲目信任钩子接收到的数据。其次，**始终使用引号包裹 shell 变量**，防止命令注入攻击。第三，**阻止路径遍历攻击**，检查文件路径中的 `..` 字符。第四，**使用绝对路径**指定脚本位置，使用 `$CLAUDE_PROJECT_DIR` 作为项目根目录引用。第五，**跳过敏感文件**，避免钩子访问 `.env`、`.git/`、密钥文件等。

### 配置安全机制

Claude Code 的钩子系统内置了安全保护机制。对设置文件的直接编辑不会立即生效，Claude Code 会在启动时捕获钩子的快照，在整个会话中使用此快照。如果 hooks 被外部程序修改，系统会发出警告，需要在 `/hooks` 菜单中查看更改后才能应用。这确保了恶意 hook 修改不会影响当前会话。

### 编写安全钩子的要点

始终在 JSON 配置中使用适当的转义，特别是引号和反斜杠。使用 `exit 0` 明确表示成功，避免依赖默认行为。为长时间运行的脚本设置合理的超时时间，防止占用过多资源。定期审查钩子配置，移除不再使用的钩子以减少攻击面。

<AdPlaceholder />

## 调试与故障排除

### 基本调试步骤

当钩子不按预期工作时，请按以下步骤排查。首先，使用 `/hooks` 命令确认钩子已正确注册。其次，使用 JSON 验证工具检查配置文件语法是否正确。第三，在生产环境测试前先手动运行钩子命令验证其行为。第四，确保脚本文件具有执行权限（`chmod +x script.sh`）。第五，使用 `claude --debug` 模式运行查看详细的钩子执行日志。

### 常见问题与解决方案

**引号未正确转义**是最常见的问题。在 JSON 字符串中需要使用 `\"` 来表示双引号。**匹配器不匹配**通常是因为大小写问题或工具名称拼写错误。**命令未找到**错误需要使用完整路径指定脚本位置。

### 高级调试技巧

使用 `claude --debug` 可以查看详细的执行过程：

```
[DEBUG] Executing hooks for PostToolUse:Write
[DEBUG] Found 1 hook matchers in settings
[DEBUG] Matched 1 hooks for query "Write"
[DEBUG] Executing hook command with timeout 60000ms
[DEBUG] Hook command completed with status 0
```

调试输出会显示哪个钩子正在运行、执行的具体命令、成功失败状态以及输出或错误消息。在详细模式（ctrl+o）中可以查看进度消息。

<AdPlaceholder />

## 执行详情与性能

### 执行特性

钩子执行具有以下特性。**超时控制**：默认 60 秒执行限制，可在单个命令上配置更短或更长的超时时间。**并行执行**：所有匹配的钩子并行运行，提高执行效率。**自动去重**：多个相同的钩子命令会自动去重，避免重复执行。**环境隔离**：在当前目录中运行，使用 Claude Code 的环境变量。

### 性能优化建议

避免在热路径上使用长时间运行的钩子，这会显著影响响应速度。对于需要复杂处理的场景，考虑使用后台执行或缓存结果。使用条件匹配器减少不必要的钩子触发频率。定期审查钩子配置，清理不再使用的钩子以保持系统性能。

## 总结

本参考手册涵盖了 Claude Code 钩子系统的高级配置选项和技术细节。从配置文件结构到事件类型详解，从输入输出格式到安全最佳实践，这些知识将帮助您构建强大而可靠的自动化工作流程。建议从简单的日志钩子开始，逐步探索更复杂的智能钩子和插件集成。始终注意安全最佳实践，确保钩子代码经过充分测试后再投入生产使用。

<AdPlaceholder />
