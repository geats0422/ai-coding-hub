---
title: "非交互模式与脚本化"
description: "了解如何使用 codex exec 进行非交互式运行、CI/CD 集成和自动化工作流"
tool: "codex"
slug: "non-interactive-mode"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# 非交互模式

非交互模式让您可以从脚本中运行 Codex（例如，持续集成（CI）作业）而无需打开交互式 TUI。您使用 `codex exec` 调用它。

有关标志级详细信息，请参阅 [`codex exec`](https://developers.openai.com/codex/cli/reference#codex-exec)。

<AdPlaceholder />

## 何时使用 `codex exec`

在以下情况下使用 `codex exec`：

- 作为管道的一部分运行（CI、预合并检查、计划作业）。
- 生成可以管道传输到其他工具的输出（例如，生成发布说明或摘要）。
- 使用明确的、预设的沙箱和批准设置运行。

## 基本用法

将任务提示词作为单个参数传递：

```bash
codex exec "summarize the repository structure and list the top 5 risky areas"
```

当 `codex exec` 运行时，Codex 将进度流式传输到 `stderr`，并仅将最终代理消息打印到 `stdout`。这使得重定向或管道传输最终结果变得简单：

```bash
codex exec "generate release notes for the last 10 commits" | tee release-notes.md
```

当您不想将会话展开文件持久化到磁盘时，使用 `--ephemeral`：

```bash
codex exec --ephemeral "triage this repository and suggest next steps"
```

## 权限和安全性

默认情况下，`codex exec` 在只读沙箱中运行。在自动化中，根据工作流设置最少的所需权限：

- 允许编辑：`codex exec --full-auto "<task>"`
- 允许更广泛的访问：`codex exec --sandbox danger-full-access "<task>"`

<Callout type="warning">
仅在受控环境（例如，隔离的 CI 运行器或容器）中使用 `danger-full-access`。
</Callout>

如果您配置了启用的 MCP 服务器且其 `required = true` 初始化失败，`codex exec` 会出错退出，而不是在没有该服务器的情况下继续。

## 使输出机器可读

要在脚本中消费 Codex 输出，请使用 JSON Lines 输出：

```bash
codex exec --json "summarize the repo structure" | jq
```

启用 `--json` 时，`stdout` 成为 JSON Lines（JSONL）流，以便您可以捕获 Codex 运行时的每个事件。事件类型包括 `thread.started`、`turn.started`、`turn.completed`、`turn.failed`、`item.*` 和 `error`。

项目类型包括代理消息、推理、命令执行、文件更改、MCP 工具调用、网页搜索和计划更新。

示例 JSON 流（每行是一个 JSON 对象）：

```jsonl
{"type":"thread.started","thread_id":"0199a213-81c0-7800-8aa1-bbab2a035a53"}
{"type":"turn.started"}
{"type":"item.started","item":{"id":"item_1","type":"command_execution","command":"bash -lc ls","status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_3","type":"agent_message","text":"Repo contains docs, sdk, and examples directories."}}
{"type":"turn.completed","usage":{"input_tokens":24763,"cached_input_tokens":24448,"output_tokens":122}}
```

如果您只需要最终消息，请使用 `-o <path>`/`--output-last-message <path>` 将其写入文件。这会将最终消息写入文件，并且仍然打印到 `stdout`（请参阅 [`codex exec`](https://developers.openai.com/codex/cli/reference#codex-exec) 了解详情）。

## 使用架构创建结构化输出

如果下游步骤需要结构化数据，请使用 `--output-schema` 请求符合 JSON Schema 的最终响应。这对于需要稳定字段的自动化工作流很有用（例如，作业摘要、风险报告或发布元数据）。

`schema.json`：

```json
{
  "type": "object",
  "properties": {
    "project_name": { "type": "string" },
    "programming_languages": {
      "type": "array",
      "items": { "type": "string" }
    }
  },
  "required": ["project_name", "programming_languages"],
  "additionalProperties": false
}
```

使用架构运行 Codex 并将最终 JSON 响应写入磁盘：

```bash
codex exec "Extract project metadata" \
  --output-schema ./schema.json \
  -o ./project-metadata.json
```

示例最终输出（stdout）：

```json
{
  "project_name": "Codex CLI",
  "programming_languages": ["Rust", "TypeScript", "Shell"]
}
```

## 在 CI 中进行身份验证

`codex exec` 默认重用保存的 CLI 凭据。在 CI 中，通常需要明确提供凭据：

- 将 `CODEX_API_KEY` 设置为作业的密钥环境变量。
- 注意提示词和工具输出：它们可能包含敏感代码或数据。

要为单次运行使用不同的 API 密钥，内联设置 `CODEX_API_KEY`：

```bash
CODEX_API_KEY=<api-key> codex exec --json "triage open bug reports"
```

`CODEX_API_KEY` 仅在 `codex exec` 中受支持。

## 恢复非交互式会话

如果您需要继续之前的运行（例如，两阶段管道），使用 `resume` 子命令：

```bash
codex exec "review the change for race conditions"
codex exec resume --last "fix the race conditions you found"
```

您还可以使用 `codex exec resume <SESSION_ID>` 定位特定的会话 ID。

## 需要 Git 存储库

Codex 要求命令在 Git 存储库内运行以防止破坏性更改。如果您确定环境是安全的，使用 `codex exec --skip-git-repo-check` 覆盖此检查。

## 常见自动化模式

### 示例：在 GitHub Actions 中自动修复 CI 故障

您可以使用 `codex exec` 在 CI 工作流失败时自动提出修复。典型模式是：

1. 当您的主要 CI 工作流完成并出错时触发后续工作流。
2. 检出失败的提交 SHA。
3. 安装依赖项并使用狭窄的提示词和最少的权限运行 Codex。
4. 重新运行测试命令。
5. 用生成的补丁打开拉取请求。

#### 使用 Codex CLI 的最小工作流

以下示例显示了核心步骤。根据您的堆栈调整安装和测试命令。

```yaml
name: Codex auto-fix on CI failure

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-fix:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      FAILED_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      FAILED_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.FAILED_HEAD_SHA }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm i; fi

      - name: Install Codex
        run: npm i -g @openai/codex

      - name: Authenticate Codex
        run: codex login --api-key "$OPENAI_API_KEY"

      - name: Run Codex
        run: |
          codex exec --full-auto --sandbox workspace-write \
            "Read the repository, run the test suite, identify the minimal change needed to make all tests pass, implement only that change, and stop. Do not refactor unrelated files."

      - name: Verify tests
        run: npm test --silent

      - name: Create pull request
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          branch: codex/auto-fix-${{ github.event.workflow_run.run_id }}
          base: ${{ env.FAILED_HEAD_BRANCH }}
          title: "Auto-fix failing CI via Codex"
```

#### 替代方案：使用 Codex GitHub Action

如果您想避免自己安装 CLI，可以通过 [Codex GitHub Action](https://developers.openai.com/codex/github-action) 运行 `codex exec`，并将提示词作为输入传递。

<AdPlaceholder />
