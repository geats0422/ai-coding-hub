---
title: "自动化任务配置"
description: "了解如何配置 Codex 自动化任务，包括创建、调度和安全最佳实践"
tool: "codex"
slug: "automations"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# 自动化

<div class="feature-grid">

<div>

自动化后台中的常规任务。Codex 将结果添加到收件箱，或者如果没有任何可报告的内容则自动存档任务。您可以将自动化与[技能](https://developers.openai.com/codex/skills)结合以用于更复杂的任务。

自动化在 Codex 应用中本地运行。应用需要正在运行，并且所选项目需要在磁盘上可用。

在 Git 存储库中，每个自动化运行在新的[工作树](https://developers.openai.com/codex/app/worktrees)中，因此它不会干扰您的主要检出。在非版本控制项目中，自动化直接在工作目录中运行。

</div>

<CodexScreenshot
  alt="自动化创建表单界面，带有日程安排和提示词字段"
  lightSrc="/images/codex/app/create-automation-light.webp"
  darkSrc="/images/codex/app/create-automation-dark.webp"
  maxHeight="400px"
/>

</div>

<AdPlaceholder />

## 管理任务

所有自动化及其运行都可以在 Codex 应用侧边栏中的自动化窗格中找到。

"分类"部分充当您的收件箱。带有结果的研究运行会显示在那里，您可以过滤收件箱以显示所有研究运行或仅显示未读的研究运行。

当自动化在 Git 存储库中运行时，Codex 使用专用的后台[工作树](https://developers.openai.com/codex/app/features#worktree-support)。在非版本控制项目中，自动化直接在工作目录中运行。考虑使用 Git 以启用在后台工作树上运行。您可以让同一个自动化在多个项目上运行。

自动化使用您的默认沙箱设置。在只读模式下，如果工具调用需要修改文件、网络访问或使用您计算机上的应用程序，工具调用会失败。启用完全访问后，后台自动化会带来更高的风险。您可以在[设置](https://developers.openai.com/codex/app/settings)中调整沙箱设置，并使用[规则](https://developers.openai.com/codex/rules)有选择地允许列表命令。

为了保持自动化的可维护性和可共享性，您可以使用[技能](https://developers.openai.com/codex/skills)来定义操作并向 Codex 提供工具和上下文。您可以通过在自动化中使用 `$skill-name` 显式触发技能。

## 安全测试自动化

在安排自动化之前，先在常规线程中手动测试提示词。这可以帮助您确认：

- 提示词清晰且范围正确。
- 所选模型和工具的行为符合预期。
- 产生的差异是可审查的。

当您开始安排运行时，仔细检查前几次输出，并根据需要调整提示词或频率。

## 自动化的清理工作树

对于 Git 存储库，自动化运行在工作树上。频繁的日程安排可能会随着时间的推移创建许多工作树。存档您不再需要的自动化运行，除非您打算保留它们的工作树，否则避免固定运行。

## 权限和安全性模型

自动化设计为无人值守运行，并使用您的默认沙箱设置。

- 如果您的沙箱模式是**只读**，如果工具调用需要修改文件、访问网络或使用您计算机上的应用程序，工具调用会失败。考虑将沙箱设置更新为工作区写入。
- 如果您的沙箱模式是**工作区写入**，如果工具调用需要修改工作区之外的文件、访问网络或使用您计算机上的应用程序，工具调用会失败。您可以使用[规则](https://developers.openai.com/codex/rules)有选择地允许列表命令在沙箱之外运行。
- 如果您的沙箱模式是**完全访问**，后台自动化会带来更高的风险，因为 Codex 可能会修改文件、运行命令并在没有询问的情况下访问网络。考虑更新沙箱设置为工作区写入，并使用[规则](https://developers.openai.com/codex/rules)有选择地定义代理可以在完全访问下运行哪些命令。

如果您在托管环境中，管理员可以使用管理员强制的需求限制这些行为。例如，他们可以禁止 `approval_policy = "never"` 或约束允许的沙箱模式。请参阅[管理员强制需求 (`requirements.toml`)](https://developers.openai.com/codex/security#admin-enforced-requirements-requirementstoml)。

当您的组织策略允许时，自动化使用 `approval_policy = "never"`。如果 `approval_policy = "never"` 被管理员需求禁止，自动化会回退到所选模式的批准行为。

## 示例

### 自动创建新技能

```markdown
扫描过去一天的所有 `~/.codex/sessions` 文件，如果使用特定技能时有任何问题，更新技能使其更有帮助。仅限个人技能，无存储库技能。

如果有一些我们经常做但挣扎的事情，我们应该保存为技能以加快未来的工作，那就去做吧。

绝对不要觉得您需要更新任何内容——只有在有充分理由时才这样做！

让我知道您是否制作了任何。
```

### 保持项目最新

```markdown
查看最新的远程 origin/master 或 origin/main。然后生成过去 24 小时提交到 <DIRECTORY> 的执行简报。

格式 + 结构：

- 使用丰富的 Markdown（H1 工作流部分、项目符号列表、子标题斜体、根据需要使用水平规则）。
- 序言可以读作"这是过去 24 小时 <directory> 的简报："
- 子标题应该读作"带有所有者；按工作流分组的叙事性讲解。"
- 按工作流分组而不是列出每个提交。工作流标题应为 H1。
- 为每个工作流写一段简短的叙述性解释。
- 在使内容更可读时使用项目符号和加粗
- 如果有意义，可以按人列出项目符号，但要加粗他们的名字

内容要求：

- 内联包含 PR 链接（例如 [#123](...)）不带"PRs："标签。
- 不要包含提交哈希或"关键提交"部分。
- 如果多个 PR 出现在一个工作流下是可以的，但要避免每个提交的项目符号列表。

范围规则：

- 仅包括当前工作目录（或主检出等效物）中的更改
- 仅包括过去 24 小时的提交
- 如果有帮助，使用 `gh` 获取 PR 标题和描述
  还可以拉取 PR 审核和评论
```

### 结合自动化与技能来修复您自己的错误

创建一个新技能，尝试通过创建新的 `$recent-code-bugfix` 来修复您自己的提交引入的错误，[并将其存储在您的个人技能中](https://developers.openai.com/codex/skills#where-to-save-skills)。

```markdown
---
name: recent-code-bugfix
description: 在当前工作目录中找到并修复作者最近一周内引入的 bug。当用户想要从他们最近的更改中进行主动修复、提示词为空、或被要求分类/修复他们最近提交导致的问题时使用。根本原因必须直接映射到作者自己的更改。
---

# 最近的代码修复

## 概述

找到作者最近一周内引入的 bug，实施修复，并在可能时进行验证。在当前工作目录中操作，假设代码是本地的，并确保根本原因与作者自己的编辑直接相关。

## 工作流

### 1) 建立最近的更改范围

使用 Git 识别作者和上周更改的文件。

- 从 `git config user.name`/`user.email` 确定作者。如果不可用，使用环境中的当前用户名或询问一次。
- 使用 `git log --since=1.week --author=<author>` 列出最近的提交和文件。关注这些提交触摸的文件。
- 如果用户的提示词为空，直接继续此默认范围。

### 2) 找到与最近更改相关的具体失败

优先考虑直接归因于作者编辑的缺陷。

- 如果本地有日志或 CI 输出可用，查找最近的失败（测试、lint、运行时错误）。
- 如果未提供失败，运行最小的相关验证（单个测试、文件级 lint 或目标重现）触摸编辑的文件。
- 确认根本原因与作者的编辑直接相关，而不是无关的传统问题。如果只发现无关失败，停止并报告未检测到符合条件的 bug。

### 3) 实施修复

进行与项目约定一致的最小修复。

- 仅更新解决问题所需的文件。
- 不要添加额外的防御检查或无关的重构。
- 保持与本地样式和测试一致。

### 4) 验证

尽可能尝试验证。

- 首选最小的验证步骤（目标测试、聚焦 lint 或直接重现命令）。
- 如果无法运行，说明会运行什么以及为什么未执行。

### 5) 报告

总结根本原因、修复和执行的验证。明确说明根本原因如何与作者最近的更改相关。
```

之后，创建新的自动化：

```markdown
检查我过去 24 小时的提交并提交一个 $recent-code-bugfix。
```

<AdPlaceholder />
