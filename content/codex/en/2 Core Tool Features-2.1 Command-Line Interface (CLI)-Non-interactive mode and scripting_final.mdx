---
title: "Non-interactive mode and scripting"
description: "Learn how to use codex exec for non-interactive runs, CI/CD integration, and automated workflows"
tool: "codex"
slug: "non-interactive-mode"
locale: "en"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# Non-interactive mode

Non-interactive mode lets you run Codex from a script (for example, a continuous integration (CI) job) without opening an interactive TUI. You call it with `codex exec`.

See [@@P1@@](https://developers.openai.com/codex/cli/reference#codex-exec) for flag-level details.

<AdPlaceholder />

## When to use `codex exec`

Use `codex exec` in the following situations:

- Run as part of a pipeline (CI, pre-merge checks, scheduled jobs).
- Generate output that can be piped to other tools (e.g., generate release notes or summaries).
- Run with clear, preset sandbox and approval settings.

## Basic usage

Pass the task prompt word as a single argument:
```bas
codex exec "summarize the repository structure and list the top 5 risky areas"
```When
 `codex exec` runs, the Codex streams progress to `stderr` and only prints final agent messages to `stdout`. This makes it simple to redirect or pipe the final result:
```bas
codex exec "generate release notes for the last 10 commits" | tee release-notes.md
```Use
 `--ephemeral` when you do not want to persist the session expansion file to disk:
```bas
codex exec --ephemeral "triage this repository and suggest next steps"
```
## Permissions and Security

By default, `codex exec` runs in a read-only sandbox. In automation, set the minimum required permissions based on the workflow:

- Editing allowed: `codex exec --full-auto "<task>"`
- Allow wider access: `codex exec --sandbox danger-full-access "<task>"`

<Callout type="warning">
Only use `danger-full-access` in a controlled environment (for example, an isolated CI runner or container).
</Callout>

If you configure an enabled MCP server and its `required = true` initialization fails, `codex exec` will exit with an error instead of continuing without the server.

## Make the output machine readable

To consume Codex output in a script, use the JSON Lines output:
```bas
codex exec --json "summarize the repo structure" | jq
```When
 `--json` is enabled, `stdout` becomes a JSON Lines (JSONL) stream so that you can capture every event while the Codex is running. Event types include `thread.started`, `turn.started`, `turn.completed`, `turn.failed`, `item.*`, and `error`.

Project types include agent messaging, inference, command execution, file changes, MCP tool calls, web searches, and scheduled updates.

Example JSON stream (each line is a JSON object):
```json
{"type":"thread.started","thread_id":"0199a213-81c0-7800-8aa1-bbab2a035a53"}
{"type":"turn.started"}
{"type":"item.started","item":{"id":"item_1","type":"command_execution","command":"bash -lc ls","status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_3","type":"agent_message","text":"Repo contains docs, sdk, and examples directories."}}
{"type":"turn.completed","usage":{"input_tokens":24763,"cached_input_tokens":24448,"output_tokens":122}}
```If
 you only need the final message, use `-o <path>`/`--output-last-message <path>` to write it to a file. This writes the final message to the file and still prints to `stdout` (see [@@P3@@](https://developers.openai.com/codex/cli/reference#codex-exec) for details).

## Create structured output using schema

If downstream steps require structured data, use `--output-schema` to request a final response that conforms to JSON Schema. This is useful for automated workflows that require stable fields (for example, job summaries, risk reports, or release metadata).

`schema.json`ï¼š
```jso
{
  "type": "object",
  "properties": {
    "project_name": { "type": "string" },
    "programming_languages": {
      "type": "array",
      "items": { "type": "string" }
    }
  },
  "required": ["project_name", "programming_languages"],
  "additionalProperties": false
}
```Run
 the Codex using the schema and write the final JSON response to disk:
```bas
codex exec "Extract project metadata" \
  --output-schema ./schema.json \
  -o ./project-metadata.json
```Example
 final output (stdout):
```jso
{
  "project_name": "Codex CLI",
  "programming_languages": ["Rust", "TypeScript", "Shell"]
}
```
## Authenticate in CI

`codex exec` Reuse saved CLI credentials by default. In CI, credentials typically need to be provided explicitly:

- Set `CODEX_API_KEY` as the job's key environment variable.
- Be aware of prompt words and tool output: they may contain sensitive code or data.

To use a different API key for a single run, set `CODEX_API_KEY` inline:
```bas
CODEX_API_KEY=<api-key> codex exec --json "triage open bug reports"
`
```CODEX_API_KEY
` Only supported in `codex exec`.

## Resume non-interactive session

If you need to continue a previous run (for example, a two-stage pipeline), use the `resume` subcommand:
```bas
codex exec "review the change for race conditions"
codex exec resume --last "fix the race conditions you found"
```You
 can also use `codex exec resume <SESSION_ID>` to target a specific session ID.

## Requires Git repository

Codex requires commands to be run within a Git repository to prevent destructive changes. If you are sure the environment is safe, use `codex exec --skip-git-repo-check` to override this check.

## Common automation patterns

### Example: Automatically fix CI failures in GitHub Actions

You can use `codex exec` to automatically propose fixes when a CI workflow fails. Typical patterns are:

1. Trigger subsequent workflows when your main CI workflow completes with an error.
2. Check out the failed commit SHA.
3. Install dependencies and run Codex with narrow prompt words and minimal permissions.
4. Rerun the test command.
5. Open a pull request with the generated patch.

#### Minimal workflow using Codex CLI

The following example shows the core steps. Adapt the installation and test commands to your stack.
```yam
name: Codex auto-fix on CI failure

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-fix:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      FAILED_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      FAILED_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.FAILED_HEAD_SHA }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm i; fi

      - name: Install Codex
        run: npm i -g @openai/codex

      - name: Authenticate Codex
        run: codex login --api-key "$OPENAI_API_KEY"

      - name: Run Codex
        run: |
          codex exec --full-auto --sandbox workspace-write \
            "Read the repository, run the test suite, identify the minimal change needed to make all tests pass, implement only that change, and stop. Do not refactor unrelated files."

      - name: Verify tests
        run: npm test --silent

      - name: Create pull request
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          branch: codex/auto-fix-${{ github.event.workflow_run.run_id }}
          base: ${{ env.FAILED_HEAD_BRANCH }}
          title: "Auto-fix failing CI via Codex"
```
#### Alternative: Use Codex GitHub Action

If you want to avoid installing the CLI yourself, you can run `codex exec` via [Codex GitHub Action](https://developers.openai.com/codex/github-action) and pass the prompt word as input.

<AdPlaceholder />
