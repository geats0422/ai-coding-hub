---
title: "Automated task configuration"
description: "Learn how to configure Codex automation tasks, including creation, scheduling, and security best practices"
tool: "codex"
slug: "automations"
locale: "en"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# Automation

<div class="feature-grid">

<div>

Automate routine tasks in the background. Codex adds the results to the inbox or automatically archives the task if there is nothing to report. You can combine automation with [技能](https://developers.openai.com/codex/skills) for more complex tasks.

Automation runs locally in the Codex app. The app needs to be running and the selected items need to be available on disk.

In a Git repository, each automation runs in a new P1, so it doesn't interfere with your main checkout. In non-version controlled projects, automation runs directly in the working directory.

</div>

<CodexScreenshot
  alt="自动化创建表单界面，带有日程安排和提示词字段"
  lightSrc="/images/codex/app/create-automation-light.webp"
  darkSrc="/images/codex/app/create-automation-dark.webp"
  maxHeight="400px"
/>

</div>

<AdPlaceholder />

## Management tasks

All automations and their runs can be found in the Automation pane in the sidebar of the Codex app.

The Categories section acts as your inbox. Study runs with results will appear there, and you can filter your inbox to show all study runs or only unread study runs.Codex uses a dedicated backend when automation runs within a Git repository. In non-version controlled projects, automation runs directly in the working directory. Consider using Git to enable running on the background work tree. You can have the same automation run on multiple projects.

Automation uses your default sandbox settings. In read-only mode, tool calls fail if they require modifying files, network access, or using applications on your computer. When full access is enabled, background automation creates a higher risk. You can adjust the sandbox settings in [设置](https://developers.openai.com/codex/app/settings) and selectively allow list commands using [规则](https://developers.openai.com/codex/rules).

To keep your automation maintainable and shareable, you can use [技能](https://developers.openai.com/codex/skills) to define actions and provide tools and context to the Codex. You can trigger skills explicitly by using `$skill-name` in automation.

## Security test automation

Before scheduling automation, manually test the prompt words in a regular thread. This can help you confirm:

- Prompt words are clear and correctly scoped.
- The selected models and tools behave as expected.
- The resulting differences are reviewable.

When you start scheduling a run, carefully review the first few outputs and adjust the prompt words or frequency as needed.

## Automatically clean up the work tree

For Git repositories, automation runs on the work tree. Frequent scheduling may create many work trees over time. Archive automation runs you no longer need and avoid pinned runs unless you plan to retain their working tree.

## Permissions and Security Model

Automation is designed to run unattended and use your default sandbox settings.- If your sandbox mode is **read-only**, tool calls will fail if they require modifying files, accessing the network, or using applications on your computer. Consider updating the sandbox settings to workspace writing.
- If your sandbox mode is **Workspace Write**, tool calls will fail if they require modifying files outside the workspace, accessing the network, or using applications on your computer. You can use [规则](https://developers.openai.com/codex/rules) to selectively allow list commands to run outside of the sandbox.
- If your sandbox mode is **Full Access**, background automation poses a higher risk as Codex may modify files, run commands, and access the network without asking. Consider updating the sandbox settings for workspace writes and using [规则](https://developers.openai.com/codex/rules) to selectively define which commands the agent can run with full access.

If you are in a managed environment, administrators can limit these behaviors using administrator-enforced requirements. For example, they can disable `approval_policy = "never"` or constrain allowed sandbox modes. See [管理员强制需求 (@@P1@@)](https://developers.openai.com/codex/security#admin-enforced-requirements-requirementstoml).

Automation uses `approval_policy = "never"` when your organization's policies allow it. If `approval_policy = "never"` is disabled by an administrator requirement, the automation will fall back to the approved behavior of the selected mode.

## Example

### Automatically create new skills
```markdow
扫描过去一天的所有 `~/.codex/sessions` 文件，如果使用特定技能时有任何问题，更新技能使其更有帮助。仅限个人技能，无存储库技能。

如果有一些我们经常做但挣扎的事情，我们应该保存为技能以加快未来的工作，那就去做吧。

绝对不要觉得您需要更新任何内容——只有在有充分理由时才这样做！

让我知道您是否制作了任何。
```
### Keep projects up to date
```markdow
查看最新的远程 origin/master 或 origin/main。然后生成过去 24 小时提交到 `<DIRECTORY>` 的执行简报。

格式 + 结构：

- 使用丰富的 Markdown（H1 工作流部分、项目符号列表、子标题斜体、根据需要使用水平规则）。
- 序言可以读作"这是过去 24 小时 <directory> 的简报："
- 子标题应该读作"带有所有者；按工作流分组的叙事性讲解。"
- 按工作流分组而不是列出每个提交。工作流标题应为 H1。
- 为每个工作流写一段简短的叙述性解释。
- 在使内容更可读时使用项目符号和加粗
- 如果有意义，可以按人列出项目符号，但要加粗他们的名字

内容要求：

- 内联包含 PR 链接（例如 [#123](...)）不带"PRs："标签。
- 不要包含提交哈希或"关键提交"部分。
- 如果多个 PR 出现在一个工作流下是可以的，但要避免每个提交的项目符号列表。

范围规则：

- 仅包括当前工作目录（或主检出等效物）中的更改
- 仅包括过去 24 小时的提交
- 如果有帮助，使用 `gh` 获取 PR 标题和描述
  还可以拉取 PR 审核和评论
```
### Combine automation and skills to fix your own errors

Create a new skill and try to fix the bug introduced by your own commit by creating a new `$recent-code-bugfix`, [并将其存储在您的个人技能中](https://developers.openai.com/codex/skills#where-to-save-skills).
```markdow
---
name: recent-code-bugfix
description: 在当前工作目录中找到并修复作者最近一周内引入的 bug。当用户想要从他们最近的更改中进行主动修复、提示词为空、或被要求分类/修复他们最近提交导致的问题时使用。根本原因必须直接映射到作者自己的更改。
---

# 最近的代码修复

## 概述

找到作者最近一周内引入的 bug，实施修复，并在可能时进行验证。在当前工作目录中操作，假设代码是本地的，并确保根本原因与作者自己的编辑直接相关。

## 工作流

### 1) 建立最近的更改范围

使用 Git 识别作者和上周更改的文件。

- 从 `git config user.name`/`user.email` 确定作者。如果不可用，使用环境中的当前用户名或询问一次。
- 使用 `git log --since=1.week --author=<author>` 列出最近的提交和文件。关注这些提交触摸的文件。
- 如果用户的提示词为空，直接继续此默认范围。

### 2) 找到与最近更改相关的具体失败

优先考虑直接归因于作者编辑的缺陷。

- 如果本地有日志或 CI 输出可用，查找最近的失败（测试、lint、运行时错误）。
- 如果未提供失败，运行最小的相关验证（单个测试、文件级 lint 或目标重现）触摸编辑的文件。
- 确认根本原因与作者的编辑直接相关，而不是无关的传统问题。如果只发现无关失败，停止并报告未检测到符合条件的 bug。

### 3) 实施修复

进行与项目约定一致的最小修复。

- 仅更新解决问题所需的文件。
- 不要添加额外的防御检查或无关的重构。
- 保持与本地样式和测试一致。

### 4) 验证

尽可能尝试验证。

- 首选最小的验证步骤（目标测试、聚焦 lint 或直接重现命令）。
- 如果无法运行，说明会运行什么以及为什么未执行。

### 5) 报告

总结根本原因、修复和执行的验证。明确说明根本原因如何与作者最近的更改相关。
```
After
 that, create a new automation:
```markdow
检查我过去 24 小时的提交并提交一个 $recent-code-bugfix。
```

<AdPlaceholder />
