---
title: "CLI基本功能"
description: "了解 Codex CLI 的核心功能，包括交互模式、命令概述和命令行选项"
tool: "codex"
slug: "codex-cli"
locale: "zh"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# Codex CLI

Codex CLI 是 OpenAI 的编码代理，您可以从终端本地运行它。它可以在您的计算机上读取、更改和运行代码。
它是[开源的](https://github.com/OpenAI/Codex)，用 Rust 构建，非常快速高效。

Codex 包含在 ChatGPT Plus、Pro、Business、Edu 和 Enterprise 计划中。了解[包含的内容](https://developers.OpenAI.com/Codex/pricing)。

*图片说明：Codex CLI概述视频展示了终端界面，展示了交互式对话、代码编辑和命令执行的界面布局。 *

<AdPlaceholder />

## CLI 设置

Codex CLI 可在 macOS 和 Linux 上使用。 Windows 支持是实验性的。为了获得最佳 Windows 体验，请在 WSL 工作区中使用 Codex 并遵循我们的[Windows 设置指南](/Codex/windows)。

---

## 使用 Codex CLI### 以交互模式运行

运行 `Codex` 以启动交互式终端 UI (TUI) 会话。
```
bas
h
codex
```
您还可以在命令行上指定初始提示词。
```
bas
h
codex "Explain this codebase to me"
```
会话打开后，您可以：

- 直接向编辑器发送提示、代码片段或屏幕截图（请参阅[图像输入](#image-inputs)）。
- 在更改和内联批准或拒绝步骤之前查看Codex 时间表。
- 使用向上/向下键浏览编辑器的草稿历史记录； Codex 恢复以前的草稿文本和图像占位符。
- 完成后按 Ctrl+C 或使用 `/exit` 关闭交互式会话。

### 恢复对话

Codex 在本地存储您的记录，以便您可以从上次中断的地方继续，而不是重复上下文。当您想要重新打开具有相同代码库状态和指令的较早线程时，请使用 `resume` 子命令。- `Codex resume` 启动最近交互会话的选择器。突出显示某个运行以查看其摘要，然后按 Enter 键重新打开它。
- `Codex resume --all` 显示当前工作目录之外的会话，以便您可以重新打开任何本地运行。
- `Codex resume --last` 跳过选择器并直接跳转到在当前工作目录中启动的最后一个会话（添加`--all` 以忽略当前工作目录过滤器）。
- `Codex resume <SESSION_ID>` 目标特定运行。您可以从选择器`/status` 或`~/.Codex/sessions/` 下的文件复制ID。

非交互式自动化运行也可以恢复：
```
bas
h
codex exec resume --last "Fix the race conditions you found"
codex exec resume 7f9f9a2e-1b3c-4c7a-9b0e-.... "Implement the plan"
```
每次恢复的运行都会保留原始记录、计划历史记录和批准，因此Codex 在您提供新指令时可以使用以前的上下文。如果需要在恢复之前启动环境，可以使用`--cd`覆盖工作目录或使用`--add-dir`添加额外的根目录。

### 模型和推理

对于 Codex 中的大多数编码任务，`gpt-5.3-Codex` 是首选模型。它适用于经过 ChatGPT 身份验证的 Codex 会话，包括 Codex 应用程序、CLI、IDE 扩展和 Codex 云。使用 `/model` 命令在会话中切换模型，或在启动 CLI 时指定模型。
```
bas
h
codex --model gpt-5.3-codex
```
[详细了解 Codex 中可用的模型](https://developers.OpenAI.com/Codex/models)。

### 函数标志

Codex 包含一小组功能标志。使用 `features` 子命令检查可用功能并将其更改保留到您的配置中。
```
bas
h
codex features list
codex features enable unified_exec
codex features disable shell_snapshot
`
```
Codex
 features enable `<feature>`` 和`Codex features disable `<feature>`` 将被写入`~/.Codex/config.toml`。如果您使用 `--profile` 启动 Codex，Codex 会将更改存储在该配置文件中，而不是根配置中。

### 图像输入

附上屏幕截图或设计规范，以便 Codex 可以阅读图像详细信息以及提示词。您可以将图像粘贴到交互式编辑器中或在命令行上提供文件。
```
bas
h
codex -i screenshot.png "Explain this error"
```

```
bas
h
codex --image img1.png,img2.jpg "Summarize these diagrams"
```
Codex
 接受常见格式，例如 PNG 和 JPEG。对两个或多个图像使用逗号分隔的文件名，并将它们与文本指令结合起来以添加上下文。

### 运行本地代码审查

在 CLI 中输入 `/review` 以打开 Codex 的代码审查预设。 CLI 启动一个专门的审阅器，它可以读取您选择的差异并报告优先的、可操作的发现，而无需触及您的工作树。默认情况下，它使用当前会话模型；将`config.toml`中的`review_model`设置为覆盖。- **针对基地分支进行审查**允许您选择本地分支； Codex 将找到与其上游的合并基线，区分您的工作，并在打开拉取请求之前突出显示最大的风险。
- **查看未提交的更改** 查看已暂存、未暂存或未跟踪的所有内容，以便您可以在提交之前解决问题。
- **查看提交** 列出最近的提交，并让 Codex 读取您选择的 SHA 的精确更改集。
- **自定义审核说明** 接受您自己的措辞（例如，“关注可访问性回归”）并使用该提示词运行同一审阅者。

每次运行都会在记录中显示为自己的轮次，因此您可以随着代码的发展重新运行审核并比较反馈。### Web searchCodex 附带一个官方的网络搜索工具。对于 Codex CLI 中的本地任务，Codex 默认启用 Web 搜索并提供来自 Web 搜索缓存的结果。缓存是由OpenAI维护的Web结果索引，因此缓存模式返回预先索引的结果而不是获取实时页面。这可以减少任意实时内容的即时注入暴露，但您仍应将 Web 结果视为不可信。如果您使用`--yolo` 或其他[完全访问沙箱设置](https://developers.OpenAI.com/Codex/security)，网络搜索默认为实时结果。要获取最新数据，请传递`--search`进行单次运行或在[基本配置](https://developers.OpenAI.com/Codex/config-basic)中设置`web_search = "live"`。您还可以设置`web_search = "disabled"`来关闭该工具。每当Codex 查找某些内容时，您都会在记录或`Codex exec --json` 输出中看到`web_search` 项。

### 使用输入提示词运行

当您只需要快速回答时，请使用单个提示词运行Codex并跳过交互式用户界面。
```
bas
h
codex "explain this codebase"
```
Codex
 将读取工作目录，制定计划，将响应流式传输回您的终端并退出。将此与 `--path` 等标志结合起来以定位特定目录，或与`--model` 一起从一开始就调整行为。

### 外壳完成

通过安装为您的 shell 生成的完成脚本来加快日常使用速度：
```
bas
h
codex completion bash
codex completion zsh
codex completion fish
```
运行 shell 配置文件中的完成脚本以设置新会话的完成。例如，如果您使用 `zsh`，则可以将以下内容添加到 `~/.zshrc` 文件中：
```
bas
h
# ~/.zshrc
eval "$(codex completion zsh)"
```
启动一个新会话，键入 `Codex`，然后按 Tab 键查看完成情况。如果您看到 `command not found: compdef` 错误，请将 `autoload -Uz compinit && compinit` 添加到 `~/.zshrc` 文件中 `eval "$(Codex completion zsh)"` 行之前，然后重新启动 shell。

### 审批模式

批准模式定义Codex 在不停止确认的情况下可以执行多少操作。在交互式会话中使用 `/permissions` 可根据舒适度的变化切换模式。- **AUTO**（默认）允许Codex 在工作目录中读取文件、编辑和运行命令。在接触该范围之外的任何东西或使用网络之前，它仍然会询问。
- **只读** 将Codex 保持在咨询模式。它可以浏览文件，但在您批准计划之前不会进行更改或运行命令。
- **完全访问** 授予 Codex 无需询问即可在您的计算机上工作的能力，包括网络访问。仅当您信任代码库和任务时才谨慎使用。

Codex 始终显示其操作记录，因此您可以使用常规 git 工作流程查看或回滚更改。

### 脚本Codex使用 `exec` 子命令自动化工作流程或将 Codex 连接到现有脚本。这将以非交互方式运行Codex，将最终计划和结果传送回`stdout`。
```
bas
h
codex exec "fix the CI failure"
```
将 `exec` 与 shell 脚本结合起来构建自定义工作流程，例如自动更新更改日志、对问题进行排序或在发送 PR 之前执行编辑检查。

### 使用Codex云

`Codex cloud` 命令允许您在不离开终端的情况下分类和启动 [Codex 云任务](https://developers.OpenAI.com/Codex/cloud)。不带参数运行它以打开交互式选择器，浏览活动或已完成的任务，并将更改应用到本地项目。

您还可以直接从终端启动任务：
```
bas
h
codex cloud exec --env ENV_ID "Summarize open bugs"
```
添加`--attempts` (1-4) 以请求Codex 云生成多个解决方案（N 次最佳运行）。例如，`Codex cloud exec --env ENV_ID --attempts 3 "Summarize open bugs"`。

环境 ID 来自您的 Codex 云配置 - 使用 `Codex cloud` 并按 Ctrl+O 选择环境，或使用 Web 仪表板确认确切的值。身份验证遵循您现有的 CLI 登录，如果提交失败，命令将以非零值退出，以便您可以将其连接到脚本或 CI。

### 斜线命令斜杠命令使您可以快速访问专门的工作流程，例如 `/review`、`/fork` 或您自己的可重复使用的提示词。 Codex 附带了一组精心设计的内置命令，您可以为自己创建自定义命令，以执行特定于团队的任务或个人快捷方式。

请参阅[斜杠命令指南](https://developers.OpenAI.com/Codex/guides/slash-commands) 浏览内置命令目录，了解如何编写自定义命令以及它们在磁盘上的存储位置。

### 提示文字编辑器

当您起草较长的提示词时，切换到完整编辑器然后将结果发送回编辑器可能会更容易。

在提示词输入中，按Ctrl+G打开`VISUAL`环境变量定义的编辑器（如果不设置`VISUAL`，则使用`EDITOR`）。### 模型上下文协议 (MCP) 通过配置模型上下文协议服务器将 Codex 连接到更多工具。在 `~/.Codex/config.toml` 中添加 STDIO 或流式 HTTP 服务器，或使用 `Codex mcp` CLI 命令管理它们 - Codex 在会话启动时自动启动它们，并与内置工具一起公开它们的工具。当您需要在另一个代理中使用 Codex 时，您甚至可以将其本身作为 MCP 服务器运行。

有关示例配置、支持的身份验证流程和更详细的指南，请参阅[模型上下文协议](https://developers.OpenAI.com/Codex/mcp)。### 提示和快捷键 - 在编辑器中输入`@`即可打开工作区根目录的模糊文件搜索；按 T​​ab 或 Enter 将突出显示的路径放入消息中。
- 当Codex运行时按Enter键将新指令注入当前回合，或按Tab键将后续提示词排队到下一轮。
- 在该行前面添加 `!` 以运行本地 shell 命令（例如，`!ls`）。 Codex 将输出视为用户提供的命令的结果，并仍然应用您的批准和沙箱设置。
- 当编辑器为空时按 Esc 两次可编辑您的最后一条用户消息。按住 Esc 键可进一步返回记录，然后按 Enter 键从该点开始分支。
- 使用`Codex --cd <path>`从任何目录启动Codex以设置工作根目录，而无需先运行`cd`。活动路径显示在 TUI 标题中。
- 当您需要跨多个项目协调更改时，使用 `--add-dir` 公开更多可写根（例如，`Codex --cd apps/frontend --add-dir ../backend --add-dir ../shared`）。
- 确保在启动 Codex 之前设置好您的环境，这样就不会花费令牌来探测要激活的内容。例如，获取您的 Python 虚拟环境（或其他语言环境），启动任何所需的守护进程，并导出您希望提前使用的环境变量。
<AdPlaceholder />

<AdPlaceholder />
