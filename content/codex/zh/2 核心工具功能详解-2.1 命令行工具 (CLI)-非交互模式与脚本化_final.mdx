---
title: "非交互模式和脚本"
description: "了解如何使用 Codex exec 进行非交互式运行、CI/CD 集成和自动化工作流程"
tool: "codex"
slug: "non-interactive-mode"
locale: "zh"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# 非交互模式

非交互模式允许您从脚本（例如，持续集成 (CI) 作业）运行Codex，而无需打开交互式 TUI。你用`Codex exec`来称呼它。

有关标志级别的详细信息，请参阅[@@P1@@](https://developers.OpenAI.com/Codex/cli/reference#Codex-exec)。

<AdPlaceholder />

## 何时使用`Codex exec`

在以下情况下使用`Codex exec`：

- 作为管道的一部分运行（CI、预合并检查、计划作业）。
- 生成可以通过管道传输到其他工具的输出（例如，生成发行说明或摘要）。
- 使用清晰的预设沙箱和审批设置运行。

## 基本用法

将任务提示词作为单个参数传递：
```
bas
h
codex exec "summarize the repository structure and list the top 5 risky areas"
```
当`Codex exec` 运行时，Codex 将进度流式传输到`stderr`，并且仅将最终代理消息打印到`stdout`。这使得重定向或管道传输最终结果变得简单：
```
bas
h
codex exec "generate release notes for the last 10 commits" | tee release-notes.md
```
当您不想将会话扩展文件保留到磁盘时，请使用`--ephemeral`：
```
bas
h
codex exec --ephemeral "triage this repository and suggest next steps"
```
## 权限和安全

默认情况下，`Codex exec` 在只读沙箱中运行。在自动化中，根据工作流程设置所需的最低权限：

- 允许编辑：`Codex exec --full-auto "<task>"`
- 允许更广泛的访问：`Codex exec --sandbox danger-full-access "<task>"`

<Callout type="warning">
仅在受控环境（例如，隔离的 CI 运行程序或容器）中使用 `danger-full-access`。
</Callout>

如果配置已启用的 MCP 服务器且其 `required = true` 初始化失败，`Codex exec` 将出现错误并退出，而不是在没有服务器的情况下继续。

## 使输出机器可读

要在脚本中使用 Codex 输出，请使用 JSON Lines 输出：
```
bas
h
codex exec --json "summarize the repo structure" | jq
```
启用 `--json` 后，`stdout` 会成为 JSON Lines (JSONL) 流，以便您可以在 Codex 运行时捕获每个事件。事件类型包括`thread.started`、`turn.started`、`turn.completed`、`turn.failed`、`item.*` 和`error`。

项目类型包括代理消息传递、推理、命令执行、文件更改、MCP 工具调用、Web 搜索和计划更新。

JSON 流示例（每行都是一个 JSON 对象）：
```
json
l
{"type":"thread.started","thread_id":"0199a213-81c0-7800-8aa1-bbab2a035a53"}
{"type":"turn.started"}
{"type":"item.started","item":{"id":"item_1","type":"command_execution","command":"bash -lc ls","status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_3","type":"agent_message","text":"Repo contains docs, sdk, and examples directories."}}
{"type":"turn.completed","usage":{"input_tokens":24763,"cached_input_tokens":24448,"output_tokens":122}}
```
如果您只需要最终消息，请使用`-o <path>`/`--output-last-message <path>` 将其写入文件。这会将最终消息写入文件并仍然打印到`stdout`（有关详细信息，请参阅[@@P3@@](https://developers.OpenAI.com/Codex/cli/reference#Codex-exec)）。

## 使用模式创建结构化输出

如果下游步骤需要结构化数据，请使用`--output-schema`请求符合JSON Schema的最终响应。这对于需要稳定字段（例如作业摘要、风险报告或发布元数据）的自动化工作流程非常有用。

`schema.json`：
```
jso
n
{
  "type": "object",
  "properties": {
    "project_name": { "type": "string" },
    "programming_languages": {
      "type": "array",
      "items": { "type": "string" }
    }
  },
  "required": ["project_name", "programming_languages"],
  "additionalProperties": false
}
```
使用架构运行 Codex 并将最终 JSON 响应写入磁盘：
```
bas
h
codex exec "Extract project metadata" \
  --output-schema ./schema.json \
  -o ./project-metadata.json
```
最终输出示例（标准输出）：
```
jso
n
{
  "project_name": "Codex CLI",
  "programming_languages": ["Rust", "TypeScript", "Shell"]
}
```
## 在 CI 中进行身份验证

`Codex exec` 默认情况下重用保存的 CLI 凭据。在 CI 中，通常需要显式提供凭据：

- 将`CODEX_API_KEY` 设置为作业的关键环境变量。
- 注意提示文字和工具输出：它们可能包含敏感代码或数据。

要在单次运行中使用不同的 API 密钥，请设置 `CODEX_API_KEY` 内联：
```
bas
h
CODEX_API_KEY=<api-key> codex exec --json "triage open bug reports"
`
```
CODEX_API_KEY
` 仅在`Codex exec` 中受支持。

## 恢复非交互式会话

如果您需要继续之前的运行（例如，两阶段管道），请使用 `resume` 子命令：
```
bas
h
codex exec "review the change for race conditions"
codex exec resume --last "fix the race conditions you found"
```
您还可以使用 `Codex exec resume <SESSION_ID>` 来定位特定会话 ID。

## 需要 Git 存储库

Codex 需要在 Git 存储库中运行命令以防止破坏性更改。如果您确定环境安全，请使用 `Codex exec --skip-git-repo-check` 覆盖此检查。

## 常见的自动化模式

### 示例：自动修复 GitHub Actions 中的 CI 故障

当 CI 工作流程失败时，您可以使用 `Codex exec` 自动提出修复建议。典型的模式是：

1. 当主 CI 工作流程完成但出现错误时，触发后续工作流程。
2. 检查失败的提交 SHA。
3. 安装依赖项并使用窄提示词和最小权限运行Codex。
4. 重新运行测试命令。
5. 使用生成的补丁打开拉取请求。#### 使用 Codex CLI 的最小工作流程

下面的例子展示了核心步骤。根据您的堆栈调整安装和测试命令。
```
yam
l
name: Codex auto-fix on CI failure

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-fix:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      FAILED_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      FAILED_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.FAILED_HEAD_SHA }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm i; fi

      - name: Install Codex
        run: npm i -g @openai/codex

      - name: Authenticate Codex
        run: codex login --api-key "$OPENAI_API_KEY"

      - name: Run Codex
        run: |
          codex exec --full-auto --sandbox workspace-write \
            "Read the repository, run the test suite, identify the minimal change needed to make all tests pass, implement only that change, and stop. Do not refactor unrelated files."

      - name: Verify tests
        run: npm test --silent

      - name: Create pull request
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          branch: codex/auto-fix-${{ github.event.workflow_run.run_id }}
          base: ${{ env.FAILED_HEAD_BRANCH }}
          title: "Auto-fix failing CI via Codex"
```
#### 替代方案：使用Codex GitHub Action

如果您想避免自己安装 CLI，可以通过 [Codex GitHub Action](https://developers.OpenAI.com/Codex/github-action) 运行 `Codex exec` 并传递提示词作为输入。

<AdPlaceholder />
