---
title: "并行开发"
description: "了解如何在 Codex 应用程序中使用 Git 工作树进行并行开发并隔离对不同任务的更改"
tool: "codex"
slug: "parallel-development"
locale: "zh"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# 工作树

在Codex应用程序中，工作树允许Codex在同一个项目中运行多个独立的任务，而不会互相干扰。对于 Git 存储库，P1 在专用的后台工作树上运行，因此它们不会与您正在进行的工作发生冲突。在非版本控制的项目中，自动化直接在工作目录中运行。您还可以在工作树上手动启动线程。

<AdPlaceholder />

## 什么是工作树？工作树仅适用于属于 Git 存储库的项目，因为它在底层使用 [Git 工作树](https://git-scm.com/docs/git-worktree)。工作树允许您创建存储库的第二个副本（“签出”）。工作树在存储库中的每个文件都有自己的副本，但它们都共享有关提交、分支等的相同元数据（`.git` 文件夹）。这允许您并行检查和处理多个分支。

## 术语

- **本地结账**：您创建的存储库。有时在 Codex 应用程序中简称为 **Local**。
- **工作树**：[Git 工作树](https://git-scm.com/docs/git-worktree) 在您的Codex 应用程序中本地签出。

## 为什么使用工作树1. 与Codex并行工作，互不破坏。
2. 启动一个与你当前工作无关的线程
   - 一个暂存区域，用于对您希望 Codex 启动但尚未准备好测试的工作进行排队。

## 开始使用

工作树需要一个 Git 存储库。确保您选择的项目位于 Git 存储库中。

<Callout type="step">
1. 选择“Worktree”，在新线程视图中，选择编辑器下方的**Worktree**。 （可选）选择 [本地环境](https://developers.OpenAI.com/Codex/app/local-environments) 来运行工作树的设置脚本。

2.选择起始分支

    在编辑器下方，选择其所基于的 Git 分支。这可以是您的 `main` / `master` 分支、功能分支或具有未提交本地更改的当前分支。3. 提交您的提示词

    提交您的任务，Codex 将根据您选择的分支创建一个 Git 工作树。默认情况下，Codex 在["detached HEAD"](https://git-scm.com/docs/git-checkout#_detached_head) 中工作。

4. 验证您的更改

    准备好后，请根据您的项目和流程，按照下面 [验证和推送工作流更改](#验证和推送工作流更改) 中的路径之一进行操作。
</Callout>

## 验证并推送工作流程更改

工作树的外观和感觉很像您本地的结帐处。但是 **Git 只允许一次检查一个地方的分支**。如果你在工作树上签出一个分支，你不能同时在本地签出它，反之亦然。

因此，选择您想要如何验证和提交 Codex 在工作树上所做的更改：1.[专门在工作树上工作](#选项-1-在工作树上工作)。当您可以直接在工作树上验证更改时，此路径效果最佳，例如因为您使用 [本地环境设置脚本](https://developers.OpenAI.com/Codex/app/local-environments) 安装了依赖项和工具。
2.[在您的本地检出中工作](#选项-2-在本地检出中工作)。当您想要将更改带回主结账时，请使用此选项，例如因为您只能运行应用程序的一个实例。

### 选项 1：在工作树上工作如果您想专门在工作树上处理更改，请使用标题中的 **在此处创建分支** 按钮将工作树转换为分支。

从这里，您可以提交更改、将分支推送到远程存储库，以及在 GitHub 上打开拉取请求。您可以使用标题中的“打开”按钮在工作树中打开 IDE，使用集成终端，或者在工作树目录中执行您需要执行的任何其他操作。

<Callout type="note">
如果您在工作树上创建分支，则无法在任何其他工作树（包括本地签出）中签出它。
</Callout>

*图片描述：工作树线程视图界面，显示分支控制和工作树详细信息。 *

如果您打算继续在这个分支上工作，您可以[将其添加到侧边栏](#将工作树添加到侧边栏)。否则，在完成后归档线程，以便可以删除工作树。

### 选项 2：在本地结账中工作如果您不想直接在工作树上验证更改，而是想在本地结帐时检查它们，请单击标题中的 **与本地同步**。

您可以选择创建新分支或同步到现有分支。

您可以随时与本地同步。再次单击标题中的 **与本地同步**。从这里，您可以选择同步方向（到本地或从本地）和同步方法：

- **覆盖**：使目标签出的文件和提交历史记录与源签出匹配。
- **应用**：计算自最近共享提交以来的源更改，并将该补丁应用于目标签出，保留源代码更改（而不是源提交）的目标提交历史记录。*图像描述：同步工作树对话框界面，显示应用或拉取更改的选项。 *

您可以创建多个工作树并将它们同步到同一功能分支，以将您的工作拆分为并行线程。在某些情况下，工作树上的更改可能会与本地结帐上的更改发生冲突，例如测试先前的工作树。在这种情况下，您可以使用 **覆盖本地** 选项来重置以前的更改并彻底应用工作树更改。

由于此过程使用 Git 操作，因此在同步过程中不会传输属于 `.gitignore` 文件的任何文件。

## 将工作树添加到侧边栏如果您选择上面的选项一（在工作树上工作），则在工作树上创建分支后，标题中将出现一个选项，用于将工作树添加到侧边栏。这会将工作树提升到永久位置。当您执行此操作时，它永远不会自动删除，您甚至可以从同一工作树启动新线程。

## 高级详细信息

### Codex 如何为您管理工作树Codex 将在`$CODEX_HOME/worktrees` 中创建一个工作树。起始提交将是启动线程时选择的分支的`HEAD`提交。如果您选择具有本地更改的分支，则未提交的更改也会应用到工作树。工作树不作为分支检出。它将处于[detached HEAD](https://git-scm.com/docs/git-checkout#_detached_head)状态。这意味着您可以创建多个工作树而不会污染您的分支。

### 分支限制

假设 Codex 已在工作树上完成了一些工作，并且您选择使用 **在此处创建分支** 在其上创建 `feature/a` 分支。现在您想在本地结帐处尝试一下。如果您尝试签出分支，您会收到以下错误：
```
fatal: 'feature/a' is already used by worktree at '<WORKTREE_PATH>'
```
要解决此问题，您需要签出工作树上的另一个分支而不是`feature/a`。

如果您计划在本地签出分支，请尝试工作流程 2 ([与本地同步](#选项-2-在本地检出中工作))。

<ToggleSection title="为什么存在此限制">
Git 防止同一分支同时在多个工作树中检出，因为一个分支代表单个可变引用 (`refs/heads/<name>`)，这意味着工作树的“当前检出状态”。当分支被检出时，Git 将其 HEAD 视为工作树所拥有，并期望操作（例如提交、重置、变基和合并）以明确定义的序列化方式推进该引用。允许多个工作树同时检出同一分支会在更新分支引用时产生歧义和竞争条件，可能导致提交丢失、索引不一致或冲突解决不明确。

通过强制执行一分支一工作树规则，Git 保证每个分支都有一个权威的工作副本，同时仍然允许其他工作树通过分离的 HEAD 或单独的分支安全地引用相同的提交。
</ToggleSection>

## 工作树清理工作树可能会占用大量磁盘空间。每个树都有自己的存储库文件、依赖项、构建缓存等。因此，Codex 应用程序尝试将工作树的数量保持在合理的范围内。

如果出现以下情况，工作树永远不会被清理：

- 有与之相关的固定对话
- 工作树已添加到侧边栏（见上文）

在以下情况下，工作树有资格进行清理：

- 已经超过4天了
- 你有超过10棵工作树

当满足任一条件时，Codex 在您归档线程时，或者在启动应用程序时发现没有关联线程的工作树时，会自动清理工作树。在清理工作树之前，Codex 会保存其工作的快照，您可以随时将其恢复到新的工作树中。如果您在清理工作树后打开该对话框，您将看到恢复它的选项。

## 常见问题
<ToggleSection title="我可以控制工作树的创建位置吗？">
目前还没有。 Codex 在`$CODEX_HOME/worktrees` 下创建工作树，因此可以对它们进行统一管理。
</ToggleSection>

<ToggleSection title="我可以在工作树之间移动会话吗？">
还没有。如果需要改变环境，必须在目标环境中启动一个新线程，并重复提示词。您可以尝试使用编辑器中的向上键恢复提示词。
</ToggleSection>
<ToggleSection title="如果工作树被删除，线程会发生什么？">
即使底层工作树目录被清理，线程也可以保留在您的历史记录中。但是，Codex 在清理之前保存工作树的快照，并提供在重新打开关联线程时恢复它的选项。
</ToggleSection>

<AdPlaceholder />
