---
title: "自动化任务配置"
description: "了解如何配置 Codex 自动化任务，包括创建、调度和安全最佳实践"
tool: "codex"
slug: "automations"
locale: "zh"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# 自动化

<div class="feature-grid">

<div>

在后台自动执行日常任务。 Codex 将结果添加到收件箱，或者如果没有需要报告的内容，则自动存档任务。您可以将自动化与[技能](https://developers.OpenAI.com/Codex/skills) 结合起来执行更复杂的任务。

自动化在 Codex 应用程序中本地运行。应用程序需要正在运行，并且所选项目需要在磁盘上可用。

在 Git 存储库中，每个自动化都在新的 P1 中运行，因此不会干扰您的主要结帐。在非版本控制的项目中，自动化直接在工作目录中运行。

</div><CodexScreenshot
  alt="自动化创建表单界面，带有日程安排和提示词字段"
  lightSrc="/images/Codex/app/create-automation-light.webp"
  darkSrc="/images/Codex/app/create-automation-dark.webp"
  maxHeight="400px"
/>

</div>

<AdPlaceholder />

## 管理任务

所有自动化及其运行都可以在 Codex 应用程序侧边栏的自动化窗格中找到。

“类别”部分充当您的收件箱。研究运行的结果将显示在那里，您可以过滤收件箱以显示所有研究运行或仅显示未读的研究运行。当自动化在 Git 存储库中运行时，Codex 使用专用后端。在非版本控制的项目中，自动化直接在工作目录中运行。考虑使用 Git 来启用在后台工作树上运行。您可以在多个项目上运行相同的自动化。自动化使用您的默认沙箱设置。在只读模式下，如果工具调用需要修改文件、网络访问或使用计算机上的应用程序，则会失败。启用完全访问后，后台自动化会带来更高的风险。您可以调整[设置](https://developers.OpenAI.com/Codex/app/settings)中的沙箱设置，并使用[规则](https://developers.OpenAI.com/Codex/rules)选择性地允许列表命令。

为了保持自动化的可维护性和可共享性，您可以使用[技能](https://developers.OpenAI.com/Codex/skills) 定义操作并向Codex 提供工具和上下文。您可以通过在自动化中使用`$skill-name`来显式触发技能。

## 安全测试自动化在调度自动化之前，在常规线程中手动测试提示词。这可以帮助您确认：

- 提示词清晰且范围正确。
- 所选模型和工具的行为符合预期。
- 由此产生的差异是可以审查的。

当您开始安排运行时，请仔细检查前几个输出，并根据需要调整提示词或频率。

## 自动清理工作树

对于 Git 存储库，自动化在工作树上运行。随着时间的推移，频繁的调度可能会创建许多工作树。存档自动化运行您不再需要并避免固定运行，除非您计划保留其工作树。

## 权限和安全模型自动化设计为无人值守运行并使用默认沙箱设置。 - 如果您的沙箱模式是**只读**，则如果工具调用需要修改文件、访问网络或使用计算机上的应用程序，则会失败。考虑将沙箱设置更新为工作区写入。
- 如果您的沙盒模式是**工作区写入**，如果工具调用需要修改工作区之外的文件、访问网络或使用计算机上的应用程序，则工具调用将会失败。您可以使用 [规则](https://developers.OpenAI.com/Codex/rules) 有选择地允许列表命令在沙箱外部运行。
- 如果您的沙盒模式是**完全访问**，则后台自动化会带来更高的风险，因为 Codex 可能会在不询问的情况下修改文件、运行命令和访问网络。考虑更新工作区写入的沙箱设置，并使用 [规则](https://developers.OpenAI.com/Codex/rules) 有选择地定义代理可以以完全访问权限运行哪些命令。如果您处于托管环境中，管理员可以使用管理员强制要求来限制这些行为。例如，他们可以禁用 `approval_policy = "never"` 或限制允许的沙箱模式。参见[管理员强制需求 (@@P1@@)](https://developers.OpenAI.com/Codex/security#admin-enforced-requirements-requirementstoml)。

当您的组织策略允许时，自动化会使用`approval_policy = "never"`。如果管理员要求禁用`approval_policy = "never"`，则自动化将回退到所选模式的批准行为。

## 示例

### 自动创建新技能
```
markdow
n
扫描过去一天的所有 `~/.codex/sessions` 文件，如果使用特定技能时有任何问题，更新技能使其更有帮助。仅限个人技能，无存储库技能。

如果有一些我们经常做但挣扎的事情，我们应该保存为技能以加快未来的工作，那就去做吧。

绝对不要觉得您需要更新任何内容——只有在有充分理由时才这样做！

让我知道您是否制作了任何。
```
### 保持项目最新
```
markdow
n
查看最新的远程 origin/master 或 origin/main。然后生成过去 24 小时提交到 `<DIRECTORY>` 的执行简报。

格式 + 结构：

- 使用丰富的 Markdown（H1 工作流部分、项目符号列表、子标题斜体、根据需要使用水平规则）。
- 序言可以读作"这是过去 24 小时 <directory> 的简报："
- 子标题应该读作"带有所有者；按工作流分组的叙事性讲解。"
- 按工作流分组而不是列出每个提交。工作流标题应为 H1。
- 为每个工作流写一段简短的叙述性解释。
- 在使内容更可读时使用项目符号和加粗
- 如果有意义，可以按人列出项目符号，但要加粗他们的名字

内容要求：

- 内联包含 PR 链接（例如 [#123](...)）不带"PRs："标签。
- 不要包含提交哈希或"关键提交"部分。
- 如果多个 PR 出现在一个工作流下是可以的，但要避免每个提交的项目符号列表。

范围规则：

- 仅包括当前工作目录（或主检出等效物）中的更改
- 仅包括过去 24 小时的提交
- 如果有帮助，使用 `gh` 获取 PR 标题和描述
  还可以拉取 PR 审核和评论
```
### 结合自动化和技能来修复自己的错误

创建一个新技能并尝试通过创建新的`$recent-code-bugfix`、[并将其存储在您的个人技能中](https://developers.OpenAI.com/Codex/skills#where-to-save-skills)来修复您自己的提交引入的错误。
```
markdow
n
---
name: recent-code-bugfix
description: 在当前工作目录中找到并修复作者最近一周内引入的 bug。当用户想要从他们最近的更改中进行主动修复、提示词为空、或被要求分类/修复他们最近提交导致的问题时使用。根本原因必须直接映射到作者自己的更改。
---

# 最近的代码修复

## 概述

找到作者最近一周内引入的 bug，实施修复，并在可能时进行验证。在当前工作目录中操作，假设代码是本地的，并确保根本原因与作者自己的编辑直接相关。

## 工作流

### 1) 建立最近的更改范围

使用 Git 识别作者和上周更改的文件。

- 从 `git config user.name`/`user.email` 确定作者。如果不可用，使用环境中的当前用户名或询问一次。
- 使用 `git log --since=1.week --author=<author>` 列出最近的提交和文件。关注这些提交触摸的文件。
- 如果用户的提示词为空，直接继续此默认范围。

### 2) 找到与最近更改相关的具体失败

优先考虑直接归因于作者编辑的缺陷。

- 如果本地有日志或 CI 输出可用，查找最近的失败（测试、lint、运行时错误）。
- 如果未提供失败，运行最小的相关验证（单个测试、文件级 lint 或目标重现）触摸编辑的文件。
- 确认根本原因与作者的编辑直接相关，而不是无关的传统问题。如果只发现无关失败，停止并报告未检测到符合条件的 bug。

### 3) 实施修复

进行与项目约定一致的最小修复。

- 仅更新解决问题所需的文件。
- 不要添加额外的防御检查或无关的重构。
- 保持与本地样式和测试一致。

### 4) 验证

尽可能尝试验证。

- 首选最小的验证步骤（目标测试、聚焦 lint 或直接重现命令）。
- 如果无法运行，说明会运行什么以及为什么未执行。

### 5) 报告

总结根本原因、修复和执行的验证。明确说明根本原因如何与作者最近的更改相关。
```
之后，创建一个新的自动化：
```
markdow
n
检查我过去 24 小时的提交并提交一个 $recent-code-bugfix。
```
<AdPlaceholder />

<AdPlaceholder />
