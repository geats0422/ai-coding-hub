---
title: "项目规格"
description: "了解如何使用 AGENTS.md 文件为您的 Codex 定义特定于项目的自定义指令和工作规范"
tool: "codex"
slug: "agents-md"
locale: "zh"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# 自定义指令和 AGENTS.md

Codex 在执行任何工作之前读取`AGENTS.md` 文件。通过分层全局指导和特定于项目的覆盖，您可以为每项任务建立一致的期望，无论您打开哪个存储库。

<AdPlaceholder />

## Codex 如何发现指导

Codex 在启动时构建命令链（每次运行一次；在 TUI 中，这通常意味着每次启动会话一次）。发现遵循以下优先顺序：

1. **全局范围：** 在您的Codex 主目录中（默认为`~/.Codex`，除非您设置`CODEX_HOME`），Codex 读取`AGENTS.override.md`（如果存在）。否则，Codex 读取`AGENTS.md`。 Codex 仅使用该级别的第一个非空文件。
2. **项目范围：** 从项目根目录（通常是Git根目录）开始，Codex向下遍历到你当前的工作目录。如果Codex找不到项目根目录，则仅检查当前目录。在路径上的每个目录中，它会检查`AGENTS.override.md`，然后检查`AGENTS.md`，然后检查`project_doc_fallback_filenames` 中的任何替代名称。 Codex 每个目录最多包含一个文件。
3. **合并顺序：** Codex 从根向下连接文件，用空行连接在一起。靠近当前目录的文件会覆盖之前的说明，因为它们出现在组合提示词之后。

当组合大小达到 `project_doc_max_bytes` 定义的限制（默认为 32 KiB）时，Codex 会跳过空文件并停止添加文件。有关这些旋钮的详细信息，请参阅[项目指令发现](https://developers.OpenAI.com/Codex/config-advanced#project-instructions-discovery)。当达到限制时增加限制或将指令分割到嵌套目录中。

## 创建全球指导

在您的Codex 主目录中创建持久默认值，以便每个存储库继承您的工作协议。

1.确保目录存在：
```
bas
h
    mkdir -p ~/.codex
    
```
2
. 创建具有可重用首选项的`~/.Codex/AGENTS.md`：
```
m
d
    # ~/.codex/AGENTS.md

    ## 工作协议

    - 修改 JavaScript 文件后始终运行 `npm test`。
    - 安装依赖项时优先使用 `pnpm`。
    - 在添加新的生产依赖项之前要求确认。
    
```
3
. 从任何地方运行 Codex 以确认它加载文件：
```
bas
h
    codex --ask-for-approval never "Summarize the current instructions."
    
```
预期结果：Codex 在提出工作之前参考`~/.Codex/AGENTS.md` 中的项目。

当您需要临时全局覆盖而不删除基础文件时，请使用`~/.Codex/AGENTS.override.md`。删除覆盖以恢复共享指导。

## 分层项目指令

存储库级文件让 Codex 了解项目规范，同时仍然继承全局默认值。

1. 使用基本设置在存储库根目录中添加`AGENTS.md`：
```
m
d
    # AGENTS.md

    ## 存储库期望

    - 打开拉取请求之前运行 `npm run lint`。
    - 更改行为时在 `docs/` 中记录公共实用程序。
    
```
2
. 当特定团队需要不同的规则时，在嵌套目录中添加覆盖。例如，在`services/payments/`中创建`AGENTS.override.md`：
```
m
d
    # services/payments/AGENTS.override.md

    ## 支付服务规则

    - 使用 `make test-payments` 而不是 `npm test`。
    - 在不通知安全频道的情况下永远不要轮换 API 密钥。
    
```
3
. 从付款目录启动Codex：
```
bas
h
    codex --cd services/payments --ask-for-approval never "List the instruction sources you loaded."
    
```
预期结果：Codex 首先报告全局文件，然后是存储库根 `AGENTS.md`，最后支付覆盖率。

Codex 在到达当前目录时停止搜索，从而将覆盖放置在尽可能靠近专业化作业的位置。

## 自定义替代文件名

如果您的存储库已使用不同的文件名（例如`TEAM_GUIDE.md`），请将其添加到后备列表中，以便Codex将其视为指令文件。

1. 编辑您的 Codex 配置：
```
tom
l
    # ~/.codex/config.toml
    project_doc_fallback_filenames = ["TEAM_GUIDE.md", ".agents.md"]
    project_doc_max_bytes = 65536
    
```
2
. 重新启动 Codex 或运行新命令以加载更新的配置。

Codex 现在按以下顺序检查每个目录：`AGENTS.override.md`、`AGENTS.md`、`TEAM_GUIDE.md`、`.agents.md`。指令发现时将忽略不在此列表中的文件名。较大的字节限制允许在截断之前进行更多的组合指导。

有了后备列表后，Codex 将后备文件视为指令。

当您需要不同的配置文件时，设置 `CODEX_HOME` 环境变量，例如特定于项目的自动化用户：
```
bas
h
CODEX_HOME=$(pwd)/.codex codex exec "List active instruction sources"
```
预期结果：输出列出了与自定义 `.Codex` 目录相关的文件。

## 验证您的设置

- 从存储库根运行`Codex --ask-for-approval never "Summarize the current instructions."`。 Codex 应按优先级顺序呼应全局文件和项目文件中的指导。
- 使用`Codex --cd subdir --ask-for-approval never "Show which instruction files are active."` 确认嵌套覆盖替换了更广泛的规则。
- 如果您需要审核Codex 加载了哪些指令文件，请检查`~/.Codex/log/Codex-tui.log`（如果启用了会话日志记录，则检查最新的`session-*.jsonl` 文件）。
- 如果说明看起来过时，请在目标目录中重新启动Codex。 Codex 每次运行时（以及每个 TUI 会话开始时）都会重建命令链，因此无需手动清除缓存。

## 解决发现的问题

- **未加载任何内容：** 确认您位于预期的存储库中，并且 `Codex status` 报告您预期的工作区根目录。确保指令文件包含内容； Codex 忽略空文件。
- **错误指南：** 在目录树 `AGENTS.override.md` 的更高位置或 Codex 主目录下查找。重命名或删除覆盖层以回退到常规文件。
- **Codex 忽略备用名称：** 验证`project_doc_fallback_filenames` 中列出的名称没有拼写错误，然后重新启动Codex 以使更新的配置生效。
- **指导被截断：** 增加 `project_doc_max_bytes` 或将大文件拆分到嵌套目录中，以保持关键指导的完整性。
- **配置文件混淆：** 在启动 Codex 之前运行 `echo $CODEX_HOME`。非默认值指向与您编辑的主目录不同的主目录。

## 下一步

- 访问[AGENTS.md](https://agents.md)官方网站了解更多信息。
- 查看[提示词 Codex](https://developers.OpenAI.com/Codex/prompting)，了解与持续辅导配合良好的对话模式。

<AdPlaceholder />
