---
title: "外壳命令工具"
description: "深入了解 Gemini CLI 的 run_shell_command 工具，包括交互式命令、命令限制配置和安全注意事项。"
tool: "gemini-cli"
slug: "shell-command-tool"
locale: "zh"
---

import { AdPlaceholder } from '@/components/AdPlaceholder'
import { Callout } from '@/components/Callout'

# 外壳工具(`run_shell_command`)

本文档介绍Gemini CLI 的`run_shell_command` 工具。

## 说明

使用`run_shell_command`与底层系统交互、运行脚本或
执行命令行操作。 `run_shell_command` 执行给定的 shell
命令，包括需要用户输入的交互式命令（例如`vim`、
`git rebase -i`) 如果`tools.shell.enableInteractiveShell` 设置设为
`true`。

在 Windows 上，命令通过 `powershell.exe -NoProfile -Command` 执行
（除非您明确地将 `ComSpec` 指向另一个 shell）。在其他平台上，
它们是用`bash -c`执行的。

<AdPlaceholder />

### 参数

`run_shell_command` 采用以下参数：- `command`（字符串，必需）：要执行的确切 shell 命令。
- `description`（字符串，可选）：命令的简要描述
  目的，将显示给用户。
- `directory`（字符串，可选）：目录（相对于项目根目录）
  在其中执行命令。如果未提供，该命令将在
  项目根。

## 如何将`run_shell_command` 与Gemini CLI 一起使用

使用`run_shell_command`时，该命令作为子进程执行。
`run_shell_command` 可以使用`&` 启动后台进程。工具返回
有关执行的详细信息，包括：- `Command`：执行的命令。
- `Directory`：运行命令的目录。
- `Stdout`：从标准输出流输出。
- `Stderr`：标准错误流的输出。
- `Error`：子进程报告的任何错误消息。
- `Exit Code`：命令的退出代码。
- `Signal`：如果命令由信号终止，则为信号编号。
- `Background PIDs`：启动的任何后台进程的 PID 列表。

用法：
```
run_shell_command(command="Your commands.", description="Your description of the command.", directory="Your execution directory.")
```
## `run_shell_command` 示例

列出当前目录下的文件：
```
run_shell_command(command="ls -la")
```
在特定目录中运行脚本：
```
run_shell_command(command="./my_script.sh", directory="scripts", description="Run my custom script")
```
启动后台服务器：
```
run_shell_command(command="npm run dev &", description="Start development server in background")
```
## 配置

您可以通过修改您的
`settings.json` 文件或使用Gemini CLI 中的`/settings` 命令。

### 启用交互式命令

要启用交互式命令，您需要设置
`tools.shell.enableInteractiveShell` 设置为`true`。这将使用`node-pty`
用于 shell 命令执行，允许交互式会话。如果
`node-pty`不可用，它将回退到`child_process`
实现，不支持交互式命令。

**示例`settings.json`：**
```
jso
n
{
  "tools": {
    "shell": {
      "enableInteractiveShell": true
    }
  }
}
```
### 在输出中显示颜色

要在 shell 输出中显示颜色，您需要设置 `tools.shell.showColor`
设置为`true`。 **注意：此设置仅适用于
`tools.shell.enableInteractiveShell` 已启用。**

**示例`settings.json`：**
```
jso
n
{
  "tools": {
    "shell": {
      "showColor": true
    }
  }
}
```
### 设置寻呼机

您可以通过设置为 shell 输出设置自定义分页器
`tools.shell.pager`设置。默认寻呼机是`cat`。 **注意：此设置
仅当`tools.shell.enableInteractiveShell`启用时适用。**

**示例`settings.json`：**
```
jso
n
{
  "tools": {
    "shell": {
      "pager": "less"
    }
  }
}
```
## 交互式命令

`run_shell_command` 工具现在通过集成
伪终端 (pty)。这允许您运行需要实时的命令
用户输入，例如文本编辑器（`vim`、`nano`）、基于终端的 UI（`htop`）、
和交互式版本控制操作（`git rebase -i`）。

当交互式命令运行时，您可以从 Gemini 向其发送输入
命令行界面。要关注交互式 shell，请按 `Tab`。终端输出，
包括复杂的 TUI，将被正确渲染。

## 重要提示- **安全性：**执行命令时要小心，尤其是那些
  根据用户输入构建，以防止安全漏洞。
- **错误处理：** 检查`Stderr`、`Error` 和`Exit Code` 字段以
  判断命令是否执行成功。
- **后台进程：** 当使用 `&` 在后台运行命令时，
  工具将立即返回，进程将继续运行
  背景。 `Background PIDs` 字段将包含该进程的进程 ID
  后台进程。

## 环境变量

当`run_shell_command`执行命令时，它设置`GEMINI_CLI=1`
子进程环境中的环境变量。这允许脚本或
用于检测它们是否正在 Gemini CLI 中运行的工具。

## 命令限制您可以限制`run_shell_command`可以执行的命令
工具，方法是使用`tools.core`和`tools.exclude`设置
配置文件。- `tools.core`：将 `run_shell_command` 限制为一组特定的命令，
  将条目添加到 `tools` 类别下的 `core` 列表中，格式如下
  `run_shell_command(<command>)`。例如，
  `"tools": {"core": ["run_shell_command(git)"]}` 只允许`git`
  命令。包括通用`run_shell_command`作为通配符，
  允许任何未明确阻止的命令。
- `tools.exclude`：要阻止特定命令，请将条目添加到`exclude` 列表
  在 `tools` 类别下，格式为`run_shell_command(<command>)`。对于
  例如，`"tools": {"exclude": ["run_shell_command(rm)"]}` 将阻止`rm`
  命令。

验证逻辑被设计为安全且灵活：1. **命令链接已禁用**：工具自动拆分命令
    与 `&&`、`||` 或 `;` 链接并分别验证每个部分。如果有的话
    链的一部分被禁止，整个命令被阻止。
2. **前缀匹配**：该工具使用前缀匹配。例如，如果您
    允许`git`，您可以运行`git status`或`git log`。
3. **阻止列表优先级**：始终首先检查`tools.exclude` 列表。
    如果一个命令与一个被阻止的前缀匹配，它将被拒绝，即使它也
    与 `tools.core` 中允许的前缀匹配。

### 命令限制示例

**仅允许特定命令前缀**

仅允许 `git` 和 `npm` 命令，并阻止所有其他命令：
```
jso
n
{
  "tools": {
    "core": ["run_shell_command(git)", "run_shell_command(npm)"]
  }
}
```
-
 `git status`：允许
- `npm install`：允许
- `ls -l`：被阻止

**阻止特定命令前缀**

要阻止 `rm` 并允许所有其他命令：
```
jso
n
{
  "tools": {
    "core": ["run_shell_command"],
    "exclude": ["run_shell_command(rm)"]
  }
}
```
-
 `rm -rf /`：被阻止
- `git status`：允许
- `npm install`：允许

**阻止列表优先**

如果命令前缀同时出现在`tools.core` 和`tools.exclude` 中，则该命令前缀为
被阻止。
```
jso
n
{
  "tools": {
    "core": ["run_shell_command(git)"],
    "exclude": ["run_shell_command(git push)"]
  }
}
```
-
 `git push origin main`：被阻止
- `git status`：允许

**阻止所有 shell 命令**

要阻止所有 shell 命令，请将 `run_shell_command` 通配符添加到
`tools.exclude`：
```
jso
n
{
  "tools": {
    "exclude": ["run_shell_command"]
  }
}
```
-
 `ls -l`：被阻止
- `any other command`：被阻止

<Callout type="warning">
`excludeTools` 的安全说明：`excludeTools` 中特定于命令的限制
for `run_shell_command` 基于简单的字符串匹配，可以很容易地
绕过了。此功能**不是安全机制**，不应该
依赖于安全地执行不受信任的代码。推荐使用
`coreTools` 显式选择可以执行的命令。
</Callout>

<AdPlaceholder />
